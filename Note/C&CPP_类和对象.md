# 类和对象



## 基础

#### 调用

* 访问对象成员变量和函数的方式有直接、通过指针或引用

  ```c++
  class AClass{
  public:
    int a=0;
  };

  int main(){
    AClass c;
    //直接访问
    cout<<c.a<<endl;
    //通过指针访问
    AClass * cp=&c;
    cout<<cp->a<<endl;
    //通过引用访问
    AClass & cr=c;
    cout<<cr.a<<endl;
    return 0;
  }
  ```

* 成员函数的缺省参数可以使新增函数参数时不必修改原来调用函数的部分

  可以使后面的参数缺省，不能使前面的参数缺省，即不能`FUN(,1)`

  **缺省构造函数要避免调用时和重载函数冲突**

  ```c++
  class AClass{
  public:
    FUN(int a=0,int b=1,int c=2){}
  }
  int main(){
    AClass c;
    c.FUN(1);//等价于c.FUN(1,1,2)
    return 0;
  }
  ```

* 成员函数声明的关键字可以只在类内部说明，类外部写函数时可以只写类型

* 静态成员可以直接通过`ClassName::FUN()`进行访问，也可以通过普通方式访问（但没有实际意义，因为并不属于某个对象）

  静态成员函数中不能有非静态成员变量和非静态成员函数，因为静态成员函数不属于某个对象，而属于同一类共有

* 常量成员函数的`const`关键字在函数名后面`void FUN()const{}`，其内不能改变属性的值，也不能调用非常量成员函数

  常量对象不能改变属性值，同一个函数加或不加`const`属性算重载，区别在于常量对象优先调用常量成员函数

  常量成员变量或对象可以通过非常量的强制转换使用改变

#### 类成员可访问范围

* 类和结构体的区别：类成员默认`private`，结构体默认`public`
* `private`可访问范围
  * 基类成员函数
  * 基类友元函数
* `protected`可访问范围
  * 基类成员函数
  * 基类友元函数
  * 派生类成员函数
* `public`可访问范围
  * 基类成员函数
  * 基类友元函数
  * 派生类成员函数
  * 派生类友元函数
  * 其他函数



## 构造函数和析构函数

#### 构造函数

* 函数名和类名相同，没有返回值，可以多个重载

* 如果没有任何构造函数，编译器自动生成一个无参构造函数和一个复制构造函数

  如果编写了构造函数，编译器不再生成无参构造函数，仍会生成复制构造函数

  如果编写了复制构造函数，编译器不会编译任何构造函数，因此一定至少还需要一个构造函数进行初始化

  初始化对象时可以有缺省参数

* 封闭类的成员对象，引用成员和`const`常量成员必须在初始化列表中初始化

#### 转换构造函数

* 即普通构造函数，在其他类型变量对该类对象赋值时，先用该变=变量生成临时对象，再按位拷贝（**不是调用复制构造函数**）

#### 复制构造函数

* 一般写`ClassName(const ClassName & c){}`

  传递引用是因为只能传递引用，因为传值会造成递归调用复制构造函数

* 三种情况调用

  * 用一个对象去初始化另一个类的对象
  * 函数形参是类的对象，可以通过传引用避免复制构造函数的调用
  * 函数返回值是类的对象
  * **等号赋值除非重载否则不是复制构造函数而是按位拷贝**

#### 析构函数

* 只能有一个析构函数，定义了则不生成缺省析构函数，否则生成什么都不做的缺省析构函数



## 其他成员

#### 成员对象（封闭类）

* 其类没有无参构造函数的成员对象必须在封闭类定义的构造函数里初始化

  成员对象先与该封闭类初始，且初始顺序和声明顺序相同，和初始列表中的顺序无关

  析构时先执行封闭类的析构函数再析构成员对象

  ```c++
  class AClass{
  private:
    int a;
  public:
    AClass(int n){
      a=n;
    }
  };
  class BClass{
  private:
    AClass c;
  public:
    BClass():c(1){};
  };
  ```

#### 友元

* 友元函数的意义是允许成员函数以外的函数访问该类的属性
* 友元类允许该类的所有成员函数访问其私有变量（所有变量）