[TOC]

# 类和对象



## 基础

#### 调用

* 访问对象成员变量和函数的方式有直接、通过指针或引用

  ```c++
  class AClass{
  public:
    int a=0;
  };

  int main(){
    AClass c;
    //直接访问
    cout<<c.a<<endl;
    //通过指针访问
    AClass * cp=&c;
    cout<<cp->a<<endl;
    //通过引用访问
    AClass & cr=c;
    cout<<cr.a<<endl;
    return 0;
  }
  ```

* 成员函数的缺省参数可以使新增函数参数时不必修改原来调用函数的部分

  可以使后面的参数缺省，不能使前面的参数缺省，即不能`FUN(,1)`

  **缺省构造函数要避免调用时和重载函数冲突**

  ```c++
  class AClass{
  public:
    FUN(int a=0,int b=1,int c=2){}
  }
  int main(){
    AClass c;
    c.FUN(1);//等价于c.FUN(1,1,2)
    return 0;
  }
  ```

* 成员函数声明的关键字可以只在类内部说明，类外部写函数时可以只写类型

* 静态成员可以直接通过`ClassName::FUN()`进行访问，也可以通过普通方式访问（但没有实际意义，因为并不属于某个对象）

  静态成员函数中不能有非静态成员变量和非静态成员函数，因为静态成员函数不属于某个对象，而属于同一类共有

* 常量成员函数的`const`关键字在函数名后面`void FUN()const{}`，其内不能改变属性的值，也不能调用非常量成员函数

  常量对象不能改变属性值，同一个函数加或不加`const`属性算重载，区别在于常量对象优先调用常量成员函数

  常量成员变量或对象可以通过非常量的强制转换使用改变

  常量成员函数的`const`如果写在前面，相当于返回了常量值，没有意义；而`static`写在前面或者后面没有区别，因为`static`不会用来声明返回值

#### 类成员可访问范围

* 类和结构体的区别：类成员默认`private`，结构体默认`public`
* `private`可访问范围
  * 基类成员函数
  * 基类友元函数
* `protected`可访问范围
  * 基类成员函数
  * 基类友元函数
  * 派生类成员函数
* `public`可访问范围
  * 基类成员函数
  * 基类友元函数
  * 派生类成员函数
  * 派生类友元函数
  * 其他函数





## 构造函数和析构函数

#### 构造函数

* 函数名和类名相同，没有返回值，可以多个重载

* 如果没有任何构造函数，编译器自动生成一个无参构造函数和一个复制构造函数

  如果编写了构造函数，编译器不再生成无参构造函数，仍会生成复制构造函数

  如果编写了复制构造函数，编译器不会编译任何构造函数，因此一定至少还需要一个构造函数进行初始化

  初始化对象时可以有缺省参数

* 可以通过初始化列表直接对成员进行赋值

  ```c++
  AClass():n(i){}
  ```

* 封闭类的成员对象，引用成员和`const`常量成员必须在初始化列表中初始化

#### 转换构造函数

* 即普通构造函数，在其他类型变量对该类对象赋值时，先用该变=变量生成临时对象，再按位拷贝（**不是调用复制构造函数**）

#### 复制构造函数

* 一般写`ClassName(const ClassName & c){}`

  传递引用是因为只能传递引用，因为传值会造成递归调用复制构造函数

* 三种情况调用

  * 用一个对象去初始化另一个类的对象
  * 函数形参是类的对象，可以通过传引用避免复制构造函数的调用
  * 函数返回值是类的对象
  * **等号赋值除非重载否则不是复制构造函数而是按位拷贝**

#### 析构函数

* 只能有一个析构函数，定义了则不生成缺省析构函数，否则生成什么都不做的缺省析构函数





## 其他成员

#### 成员对象（封闭类）

* 其类没有无参构造函数的成员对象必须在封闭类定义的构造函数里初始化

  成员对象先与该封闭类初始，且初始顺序和声明顺序相同，和初始列表中的顺序无关

  析构时先执行封闭类的析构函数再析构成员对象

  ```c++
  class AClass{
  private:
    int a;
  public:
    AClass(int n){
      a=n;
    }
  };
  class BClass{
  private:
    AClass c;
  public:
    BClass():c(1){};
  };
  ```

#### 友元

* 友元函数的意义是允许成员函数以外的函数访问该类的属性
* 友元类允许该类的所有成员函数访问其私有变量（所有变量）



## 运算符重载

#### 重载类型

* 重载为普通函数：左操作数为非类对象，且只访问公有元素

  参数个数为运算符目数

* 重载为成员函数：左操作数为类对象

  参数个数为运算符目数减一

* 重载为友元函数：左操作数为非类对象，且需要访问`private`对象

  参数个数为运算符目数

#### 实例

* 强制类型转换符：重载为成员函数，在运行中需要调用的时候自动强制转换当前类类型；无返回值类型，有返回值；形参为空

  ```c++
  operator int(){
    return n;
  }
  ```

* 函数调用运算符：将对象当作函数名进行函数调用计算；初始化时不为函数调用

  ```c++
  type operator(){}
  ```

* 下标运算符：对类成员进行数组式的读写

  返回引用保证写入（赋值）的时候做操作数为类内数组对象该元素的地址

  ```c++
  type & operator[](type n){
    return pointer[n];
  }
  ```

* 赋值运算符：一般为了方便连续赋值，返回当前类（对象）的引用

  此时类做了返回值（以及某些情况函数参数），需要复制构造函数

  ```c++
  const AClass & operator=(type n){
    return *this;
  }
  ```

  除此之外，还需要对类之间赋值重载赋值运算符（使其只是内容相同即深赋值），否则两个类指向的同一个地址（浅复制）；此时需要判断`n==c.n`先终止实参赋给形参的再次调用

  ```c++
  AClass & operator=(const AClass &c){
    if(n==c.n) return *this;
    //
    return *this;
  }
  ```

* 流运算符：输入和输出

  可以在类内重载为友元函数或类外重载为普通函数（此时访问成员必须全部是`public`）

  必须传入和返回引用，因为`cin`和`cout`不能复制

  ```c++
  friend istream & operator>>(istream &i,const AClass &c){
    i>>c.n;
    return i;
  }

  friend ostream & operator<<(ostream &o,const AClass &c){
    o<<c.n<<endl;
    return o;
  }
  ```

* 自增/自减运算符：前置运算符为一元运算符，后置运算符为二元运算符（第二个参数无用）；即作为成员函数时，前置不带参数，后置带一个无用的`int`参数

  后置运算符因为返回原值，同时还要修改现值，故返回一个复制构造函数构造的临时对象

  ```c++
  AClass & operator++(){
    n++;
    return *this;
  }
  AClass & operator++(int u){
    AClass tmp(*this);
    n++;
    return tmp;
  }
  ```

* ​

#### 注意

* 不能重载的运算符：`.`、`.*`、`::`、`?:`、`sizeof`
* 必须重载为成员函数：`()`、`[]`、`->`、`=`
* 对于双目运算符，既要支持做操作数为类的对象，又要支持为非类对象，则前者重载为成员函数，后者重载为友元函数



## 继承

#### 基础

* ```c++
  class BClass{
    
  };
  class DClass:public BClass{
    
  };
  ```

* 派生类继承基类全部成员，（如果覆盖）相当于独立重用，但不能访问基类`private`成员

  派生类可以通过同名成员覆盖基类成员，否则相当于调用基类成员